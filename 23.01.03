23.01.03

this
객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 같이 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용

정적멤버와 static
정적은 고정된 이란 의미이다 정적멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.
이들을 정적필드, 정적메소드라 한다.

정적 메소드 선언 시 주의할 사항
객체가 없어도 실행된다는 특징 때문에 정적 메소드를 선언할 때는 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 객체
자신의 참조인 this 키워드도 사용이 불가하다.
정적메소드에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

싱글톤
전체 프로그램에서 단 하나의 객체만 만들도록 보장해야하는 경우가 있는데 단 하나만 생성된다고 해서 이 객체를 싱글톤이라 한다.
싱들톤을 만드려면 외부에 new연산자로 생성자를 호출 할 수 없도록 막아야한다. 생성자를 호출한 만큼 객체가 생성되기 때문에 생성자를 외부에서
호출할 수 없도록 하려면 생성자 앞에 private접근 제한자를 붙여주어 접근을 제한한다.
외부에서 객체를 얻는 방법은 getInstance()메소드를 호출하는 방법이다 getInstance()는 단 하나의 객체만 리턴하기 때문이다.

final필드
final은 최종적 이란 뜻으로서 final필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다는 것이다
final필드의 초기값을 주는 방법은 필드 선언시 주는방법, 생성자에서 주는 방법 두가지 방법이 있다.
ex> final String nation = "korea"


상수
불변의 값을 상수(static final)라고 부른다. 불변의 값의 예시는 원주율 파이나 지구의 무게 및 둘레 등이 해당된다.
이런 불변의 값을 저장하는 필드를 자바에서는 상수constant라 한다.
static final 필드는 객체마다 존재하지 않고 클래스에만 존재한다, 그리고 한 번 초기값이 저장되면 변경할 수 없다.
ex> static final double pi = 3.14159;



final과 static final 의 차이점 알아보자
final 필드는 한 번 초기화되면 수정할 수 없는 필드이며 static final도 마찬가지다 하지만 static final은 불변의 값이며 final 값은
여러가지 값으로 초기화 할 수 있다는 차이점이 존재한다. final필드는 객체마다 저장되고 생성자의 매개값을 통해서 여러가지 값을 가질 수
있지만 static final필드는 객체마다 존재하지 않고 클래스에만 존재한다는 차이점이 있다.


패키지
패키지의 물리적인 형태는 파일 시스템의 폴더이다 
패키지는 단순히 파일 시스템의 폴더 기능만 하는 것이 아니라 클래스의 일부분으로 클래스를 유일하게 만들어주는 식별자 역활을 한다.
클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식.
형태 :  상위패키지.하위패키지.클래스
패키지는 클래스의 일부이다. 그 이유는 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스를 사용할 수 없기 때문이다.



접근제한자
접근제한자는 접근을 제한하기 위해 사용된다. 접근제한자는 public,private,protected와 같이 세 가지 종류가 있습니다.
public 접근 제한자 : 단어 뜻 그래로 외부 클래스가 자유롭게 사용 가능
protected : 같은 패키지 또는 자식 클래스에서만 사용가능
private : 외부에서 사용 불가능
default 접근제한 : 같은 패키지에 소속된 클래스에서만 사용 가능



default 접근제한은 클래스에 public을 생략했다면 클래스는 default접근 제한을 갖는다. 클래스가 default접근 제한을 가지면 같은 
패키지에서는 아무런 제한 없이 사용가능하지만 다른 패키지에서는 사용 불가하다.


Getter Setter 메소드
외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 필드에 접근하도록 유도한다.
Getter 메소드 외부로 필드값을 전달하는 것이 목적  (전송이 목적)
Setter 외부에서 값을 받아 필드를 변경하는 메소드를 Setter라고 한다. (받는게 목적)


상속
이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 중복되는 코드를 줄여준다.
프로그램에서는 자식이 부모를 선택한다
자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지 결정하고 선택된 부모클래스는 extends를 사용하여 상속받는다 
ex > class 자식클래스 extends 부모클래스 {
}

여러 개의 부모 클래스를 상속할 수 없다. 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도
상속 대상 제외

overriding(재정의, 무시한다)
부모 클래스의 메소드가 자식 클래스에서 사용하기에 부적합할 경우 자식 클래스에서 수정하여 사용한다.
메소드가 재정의될 경우 부모 객체 메소드가 숨겨지며, 자식 객체에서 메소드 호출하면 재정의된 자식 메소드가 호출됨

super(매개값,...)
매개값의 타입과 일치하는 부모 생성자를 호출합니다, 만약 매개값의 타입과 일치하는 부모 생성자가 없을 경우 컴파일 에러 발생
super(매개값,...)가 생략되면 자동으로 추가됨 부모 클래스에 기본 생성자가 없고 매개변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 super(매개값,...)
를 명시적으로 호출해야한다 super(매개값,...)는 반드시 자식 생성자 첫 줄에 위치하여야 한다.

자동타입변환
타입을 다른 타입으로 변환하는 행위를 말한다. 자식은 부모타입으로 자동 타입변환이 가능하다.
자동타입변환은 프로그램 실행 도중에 자동적으로 타입변환이 일어나는 것을 말한다.
ex > 부모타입 변수 = 자식타입;         Cat cat = new Cat(); 
자동타입변환의 개념은 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 것

필드의 다형성


추상클래스
추상클래스가 부모, 실체클래스가 자식으로 구현되어 실체 클래스는 추상 클래스의 모든 특성을 물려받고 추가적인 특성을 가질 수 있다.

추상클래스 용도
실체 클래스의 공통적인 특성을 뽑아내어 추상 클래스로 만드는 이유는 공통된 필드와 메소드의 이름을 통일할 목적 실체 클래스를 작성할 때 시간 절약을 하기 위해서이다

추상클래스
추상클래스를 선언할 때에는 클래스 선언에 abstract 키워드를 붙여야 한다. abstract를 붙이면 new 연산자를 이용해 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.
추상클래스도 일반 클래스와 만찬가지로 필드, 생성자, 메소드 선언을 할 수 있습니다. new 연산자로 직접 생성자를 호출할 수 없지만 자식 객체만 생성될 때 
super를 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 반드시 있어야 한다.

추상메소드와 재정의
추상 메소드 선언하는 방법 : [public | protected] abstract 리턴타입 메소드이름(매개변수, ''');

public abstract class Animal {
  public abstract void sound();
 }
// animal 클래스를 추상클래스로 선언하고 sound()메소드를 추상 메소드로 선언한것이다 어떤 소리를 내는지는 결정할 수 없지만 동물은 소리를 낸다는 공통적인 특징을 규정하기 위해
sound()메소드를 추상 메소드로 선언했다

인터페이스
인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역활을 합니다 개발코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킵니다. 그렇기 때문에 개발 코드는
객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다
개발코드가 직접 객체의 메소드를 호출하지 않고 중간에 인터페이스를 두는 이유는 개발코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서이다. 인터페이스는 하나의 
객체가 아니라 여러 객체들과 사용이 가능하므로 어떤 객체를 사용하느냐에 따라 실행내용과 리턴값이 다를 수 있다. 따라서 개발 코드 측면에서 코드변경없이 실행내용과 리턴값을 다양화 가능

인터페이스 선언
[public] interface 인터페이스이름 {

}

인터페이스 구현
public class Television implements RemoteControl { // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언


다중 인터페이스 구현 클래스
public class 구현클래스이름 implements 인터페이스A, 인터페이스B{

}

인터페이스 사용






